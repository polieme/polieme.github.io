<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xydcom.cn","root":"/","images":"/images","scheme":"Gemini","version":"8.3.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta property="og:type" content="article">
<meta property="og:title" content="Java编码规范">
<meta property="og:url" content="http://xydcom.cn/2019/01/24/Java%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/index.html">
<meta property="og:site_name" content="Daniel&#39;s Blog技术存放">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xydcom.cn/images/banner/banner_1.jpg">
<meta property="article:published_time" content="2019-01-24T05:17:21.000Z">
<meta property="article:modified_time" content="2021-09-07T02:05:06.039Z">
<meta property="article:author" content="Daniel">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="编码规范">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xydcom.cn/images/banner/banner_1.jpg">


<link rel="canonical" href="http://xydcom.cn/2019/01/24/Java%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Java编码规范 | Daniel's Blog技术存放</title>
  

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?54f260792b0ce4401620db3ee3bb5b52";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Daniel's Blog技术存放</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">生死看淡，不服就干</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-java"><a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Java/" rel="section"><i class="fa fa-bug fa-fw"></i>Java</a></li>
        <li class="menu-item menu-item-javascript"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Javascript/" rel="section"><i class="fab fa-xing fa-fw"></i>Javascript</a></li>
        <li class="menu-item menu-item-jquery"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/JQuery/" rel="section"><i class="fa fa-bolt fa-fw"></i>JQuery</a></li>
        <li class="menu-item menu-item-css"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/CSS/" rel="section"><i class="fab fa-css3 fa-fw"></i>CSS</a></li>
        <li class="menu-item menu-item-android"><a href="/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android/" rel="section"><i class="fab fa-android fa-fw"></i>Android</a></li>
        <li class="menu-item menu-item-后端框架"><a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/" rel="section"><i class="fab fa-modx fa-fw"></i>后端框架</a></li>
        <li class="menu-item menu-item-后端插件"><a href="/categories/%E5%90%8E%E7%AB%AF%E6%8F%92%E4%BB%B6/" rel="section"><i class="fab fa-opera fa-fw"></i>后端插件</a></li>
        <li class="menu-item menu-item-前端框架"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/" rel="section"><i class="fa fa-gem fa-fw"></i>前端框架</a></li>
        <li class="menu-item menu-item-前端插件"><a href="/categories/%E5%89%8D%E7%AB%AF%E6%8F%92%E4%BB%B6/" rel="section"><i class="fa fa-crop fa-fw"></i>前端插件</a></li>
        <li class="menu-item menu-item-安全测评"><a href="/categories/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%84/" rel="section"><i class="fa fa-lock fa-fw"></i>安全测评</a></li>
        <li class="menu-item menu-item-办公知识"><a href="/categories/%E5%8A%9E%E5%85%AC%E7%9F%A5%E8%AF%86/" rel="section"><i class="fa fa-dot-circle fa-fw"></i>办公知识</a></li>
        <li class="menu-item menu-item-服务器"><a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="section"><i class="fa fa-server fa-fw"></i>服务器</a></li>
        <li class="menu-item menu-item-中间件"><a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="section"><i class="fa fa-arrows-alt fa-fw"></i>中间件</a></li>
        <li class="menu-item menu-item-数据库"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="section"><i class="fa fa-database fa-fw"></i>数据库</a></li>
        <li class="menu-item menu-item-物联网"><a href="/categories/%E7%89%A9%E8%81%94%E7%BD%91/" rel="section"><i class="fa fa-link fa-fw"></i>物联网</a></li>
        <li class="menu-item menu-item-软件安装"><a href="/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="section"><i class="fa fa-th-large fa-fw"></i>软件安装</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">226</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">104</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">194</span></a></li>
        <li class="menu-item menu-item-待完善"><a href="/todo/" rel="section"><i class="fa fa-paper-plane fa-fw"></i>待完善</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99%E6%89%8B%E5%86%8C"><span class="nav-number">1.</span> <span class="nav-text">Java 编码规则手册</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">一、编程规约</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%91%BD%E5%90%8D%E9%A3%8E%E6%A0%BC"><span class="nav-number">2.1.</span> <span class="nav-text">（一）命名风格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.</span> <span class="nav-text">（二）常量定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">（三）代码格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89OOP%E8%A7%84%E7%BA%A6"><span class="nav-number">2.4.</span> <span class="nav-text">（四）OOP规约</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E9%9B%86%E5%90%88%E5%A4%84%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">（五）集合处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="nav-number">2.6.</span> <span class="nav-text">（六）并发处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.7.</span> <span class="nav-text">（七）控制语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%85%AB%EF%BC%89%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6"><span class="nav-number">2.8.</span> <span class="nav-text">（八）注释规约</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B9%9D%EF%BC%89%E5%85%B6%E4%BB%96"><span class="nav-number">2.9.</span> <span class="nav-text">（九）其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97"><span class="nav-number">3.</span> <span class="nav-text">二、异常日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">（一）异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%97%A5%E5%BF%97%E8%A7%84%E7%BA%A6"><span class="nav-number">3.2.</span> <span class="nav-text">（二）日志规约</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6"><span class="nav-number">4.</span> <span class="nav-text">三、安全规约</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81MySQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">5.</span> <span class="nav-text">四、MySQL数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%BB%BA%E8%A1%A8%E8%A7%84%E7%BA%A6"><span class="nav-number">5.1.</span> <span class="nav-text">（一）建表规约</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B4%A2%E5%BC%95%E8%A7%84%E7%BA%A6"><span class="nav-number">5.2.</span> <span class="nav-text">（二）索引规约</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89SQL%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.3.</span> <span class="nav-text">（三）SQL语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89ORM%E6%98%A0%E5%B0%84"><span class="nav-number">5.4.</span> <span class="nav-text">（四）ORM映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Oracle%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">6.</span> <span class="nav-text">五、Oracle数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">6.1.</span> <span class="nav-text">（一）对象命名规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89SQL%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83"><span class="nav-number">6.2.</span> <span class="nav-text">（二）SQL编写规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-number">6.3.</span> <span class="nav-text">（三）类型选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E4%BB%B6%EF%BC%9A%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="nav-number">7.</span> <span class="nav-text">附件：专有名词解释</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Daniel"
      src="/images/head/head_pic.jpg#/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Daniel</p>
  <div class="site-description" itemprop="description">生死看淡，不服就干</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">194</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">226</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/polieme" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;polieme" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/polieme@126.com" title="E-Mail → polieme@126.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/polieme" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xydcom.cn/2019/01/24/Java%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head/head_pic.jpg#/images/avatar.gif">
      <meta itemprop="name" content="Daniel">
      <meta itemprop="description" content="生死看淡，不服就干">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Daniel's Blog技术存放">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java编码规范
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-24 13:17:21" itemprop="dateCreated datePublished" datetime="2019-01-24T13:17:21+08:00">2019-01-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-07 10:05:06" itemprop="dateModified" datetime="2021-09-07T10:05:06+08:00">2021-09-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">后端开发语言</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description"> </div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="/images/banner/banner_1.jpg"></p>
<blockquote>
<p>版权说明：本文档摘抄自《阿里巴巴Java开发手册（详尽版）》<br>摘抄不意味着单纯的Copy，而是对别人知识汲取和吸收的同时添加自己的个人理解</p>
</blockquote>
<h1 id="Java-编码规则手册"><a href="#Java-编码规则手册" class="headerlink" title="Java 编码规则手册"></a>Java 编码规则手册</h1><table>
<thead>
<tr>
<th align="center">版本号</th>
<th align="center">更新时间</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">V1.0</td>
<td align="center">2018-11-22</td>
<td align="center">初始化版本</td>
</tr>
</tbody></table>
<h1 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h1><h2 id="（一）命名风格"><a href="#（一）命名风格" class="headerlink" title="（一）命名风格"></a>（一）命名风格</h2><ol>
<li><p><font color='red'>【强制】</font>代码中的命名不能以<code>下划线或美元符号</code>开始，也不能以<code>下划线或美元符号</code>结束。</p>
<p><font color='orange'>反例：</font><code>_name/__name/$name/name_/name$/name__</code></p>
</li>
<li><p><font color='red'>【强制】</font>代码中命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式</p>
<p><font color='sienna'>说明：</font>正确的英文拼写和语法可以让阅读者易于理解，便面歧义</p>
<p><font color='orange'>反例：</font><code>DaZhePromotion()[打折]/getPingFenByName()[获取评分]/int 某变量=3</code></p>
</li>
<li><p><font color='red'>【强制】</font>类名使用<code>UpperCameCase</code>风格，但以下情况例外<code>DO/BO/DTO/VO/AO/PO/UID</code>等</p>
<p><font color='green'>正例：</font><code>MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion</code></p>
<p><font color='orange'>反例：</font><code>macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</code></p>
</li>
<li><p><font color='red'>【强制】</font>方法名、参数名、成员变量、局部变量都统一使用<code>lowerCameCase</code>风格，必须遵从驼峰形式。</p>
<p><font color='green'>正例：</font><code>localValue / getHttpMessage() / inputUserId</code></p>
</li>
<li><p><font color='red'>【强制】</font>常量命名全部大写，单词间用下划线隔开，尽量将语义表达清楚，不要害怕变量长度太长。</p>
<p><font color='green'>正例：</font><code>MAX_STOCK_COUNT</code></p>
<p><font color='orange'>反例：</font><code>MAX_COUNT</code></p>
</li>
<li><p><font color='red'>【强制】</font>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾</p>
</li>
<li><p><font color='red'>【强制】</font>类型与中括号紧挨相连来表示数组</p>
<p><font color='green'>正例：</font>定义整形数组 <code>int[] arrayDemo</code></p>
<p><font color='orange'>反例：</font>在 main 参数中，使用 <code>String args[]</code>来定义</p>
</li>
<li><p><font color='red'>【强制】</font><code>POJO</code> 类中布尔类型的变量，都不要加 <code>is </code>前缀，否则部分框架解析会引起序列化错误</p>
<p><font color='orange'>反例：</font>定义为基本数据类型 <code>Boolean isDeleted</code> 的属性，它的方法也是 <code>isDeleted()</code>，<code>RPC</code>框架在反向解析的时候，“误以为”对应的属性名称是 <code>deleted</code>，导致属性获取不到，进而抛出异常</p>
</li>
<li><p><font color='red'>【强制】</font>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式</p>
<p><font color='green'>正例：</font>应用工具类包名为 <code>com.alibaba.ai.util</code>、类名为 <code>MessageUtils</code></p>
</li>
<li><p><font color='red'>【强制】</font>杜绝完全不规范的缩写，避免望文不知义</p>
<p><font color='orange'>反例：</font><code>AbstractClass</code>“缩写”命名成 <code>AbsClass</code>；<code>condition</code>“缩写”命名成 <code>condi</code>，此类随意缩写严重降低了代码的可阅读性。</p>
</li>
<li><p><font color='red'>【强制】</font>为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意</p>
<p><font color='green'>正例：</font>在<code>JDK</code>中，表达原子更新的类名为：<code>AtomicReferenceFieldUpdater</code></p>
<p><font color='orange'>反例：</font>变量 <code>int a</code> 的随意命名方式</p>
</li>
<li><p><font color='green'>【推荐】</font>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式</p>
<p><font color='sienna'>说明：</font>将设计模式体现在名字中，有利于阅读者快速理解架构设计理念</p>
<p><font color='green'>正例：</font><code>public class OrderFactory;</code>,<code> public class LoginProxy;</code>,<code>public class ResourceObserver;</code></p>
</li>
<li><p><font color='green'>【推荐】</font>接口类中的方法和属性不要加任何修饰符号（<code>public</code> 也不要加），保持代码的简洁性，并加上有效的 <code>Javadoc </code>注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量</p>
<p><font color='green'>正例：</font>接口方法签名<code> void commit()</code>;接口基础常量 <code>String COMPANY = &quot;alibaba&quot;</code>;</p>
<p><font color='orange'>反例：</font>接口方法定义 <code>public abstract void f()</code>;</p>
<p><font color='sienna'>说明：</font><code>JDK8</code> 中接口允许有默认实现，那么这个 <code>default</code> 方法，是对所有实现类都有价值的默认实现</p>
</li>
<li><p>接口和实现类的命名有两套规则</p>
<p>1）<font color='red'>【强制】</font>对于 <code>Service </code>和<code>DAO</code>类，基于 <code>SOA </code>的理念，暴露出来的服务一定是接口，内部的实现类用<code>Impl</code>的后缀与接口区别</p>
<p><font color='green'>正例：</font><code>CacheServiceImpl</code> 实现 <code>CacheService</code>接口</p>
<p>2）<font color='green'>【推荐】</font>如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形式）</p>
<p><font color='green'>正例：</font><code>AbstractTranslator</code> 实现 <code>Translatable </code>接口</p>
</li>
<li><p>【参考】枚举类名建议带上 <code>Enum</code>后缀，枚举成员名称需要全大写，单词间用下划线隔开</p>
<p><font color='sienna'>说明：</font>枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有</p>
<p><font color='green'>正例：</font>枚举名字为 <code>ProcessStatusEnum</code> 的成员名称：<code>SUCCESS / UNKNOWN_REASON</code></p>
</li>
<li><p>【参考】</p>
<ul>
<li><code>Service/DAO</code>层方法命名规则<ul>
<li>获取单个对象的方法用 <code>get </code>做前缀</li>
<li>获取多个对象的方法用 <code>list</code> 做前缀，复数形式结尾如：<code>listObjects</code></li>
<li>获取统计值的方法用 <code>count</code> 做前缀</li>
<li>插入的方法用 <code>save/insert </code>做前缀</li>
<li>删除的方法用 <code>remove/delete</code> 做前缀</li>
<li>修改的方法用 <code>update </code>做前缀</li>
</ul>
</li>
<li>领域模型命名规约<ul>
<li>数据对象：<code>xxxDO</code>，<code>xxx</code> 即为数据表名</li>
<li>数据传输对象：<code>xxxDTO</code>，<code>xxx </code>为业务领域相关的名称</li>
<li>展示对象：<code>xxxVO</code>，<code>xxx </code>一般为网页名称</li>
<li><code>POJO</code>是 <code>DO/DTO/BO/VO</code>的统称，禁止命名成 <code>xxxPOJO</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="（二）常量定义"><a href="#（二）常量定义" class="headerlink" title="（二）常量定义"></a>（二）常量定义</h2><ol>
<li><p><font color='red'>【强制】</font>不允许任何魔法值（即未经预先定义的常量）直接出现在代码中</p>
<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Magic values, except for predefined, are forbidden in coding.</span></span><br><span class="line"><span class="keyword">if</span> (key.equals(<span class="string">&quot;Id#taobao_1&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String KEY_PRE = <span class="string">&quot;Id#taobao_1&quot;</span>;  </span><br><span class="line"><span class="keyword">if</span> (KEY_PRE.equals(key)) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解</p>
<p><font color='sienna'>说明：</font><code>Long a = 2l;</code> 写的是数字的 21，还是 <code>Long</code> 型的 2?</p>
</li>
<li><p><font color='green'>【推荐】</font>不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护</p>
<p><font color='sienna'>说明：</font>大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护</p>
<p><font color='green'>正例：</font>缓存相关常量放在类 <code>CacheConsts</code> 下；系统配置相关常量放在类 <code>ConfigConsts</code> 下</p>
</li>
<li><p><font color='green'>【推荐】</font>常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量</p>
<ul>
<li>跨应用共享常量：放置在二方库中，通常是 <code>client.jar</code> 中的 <code>constant</code> 目录下</li>
<li>应用内共享常量：放置在一方库中，通常是子模块中的 <code>constant</code> 目录下</li>
</ul>
<p><font color='orange'>反例：</font>易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量</p>
<p>​    类 A 中：<code>public static final String YES = &quot;yes&quot;;</code></p>
<p>​    类 B 中：<code>public static final String YES = &quot;y&quot;;</code></p>
<p>​    <code>A.YES.equals(B.YES)</code>，预期是 <code>true</code>，但实际返回为 <code>false</code>，导致线上问题</p>
<ul>
<li>子工程内部共享常量：即在当前子工程的 <code>constant</code> 目录下</li>
<li>包内共享常量：即在当前包下单独的<code> constant</code>目录下</li>
<li>类内共享常量：直接在类内部 <code>private static final</code> 定义</li>
</ul>
</li>
<li><p><font color='green'>【推荐】</font>如果变量值仅在一个固定范围内变化用 <code>enum</code> 类型来定义（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/liaojie970/p/6474733.html">扩展<code>enmu</code>的使用方法</a>）</p>
<p><font color='sienna'>说明：</font>如果存在名称之外的延伸属性应使用 <code>enum</code> 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SeasonEnum</span> </span>&#123;</span><br><span class="line">    SPRING(<span class="number">1</span>), SUMMER(<span class="number">2</span>), AUTUMN(<span class="number">3</span>), WINTER(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seq;</span><br><span class="line"></span><br><span class="line">    SeasonEnum(<span class="keyword">int</span> seq) &#123;</span><br><span class="line">        <span class="keyword">this</span>.seq = seq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="（三）代码格式"><a href="#（三）代码格式" class="headerlink" title="（三）代码格式"></a>（三）代码格式</h2><ol>
<li><p><font color='red'>【强制】</font>大括号的使用约定。如果是大括号内为空，则简洁地写成<code>&#123;&#125;</code>即可，不需要换行；如果是非空代码块则</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行</li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左大括号前需要空格。详见第 5 条下方正例提示</p>
<p><font color='orange'>反例：</font><code>if (空格 a == b 空格)</code></p>
</li>
<li><p><font color='red'>【强制】</font><code>if/for/while/switch/do</code> 等保留字与括号之间都必须加空格</p>
</li>
<li><p><font color='red'>【强制】</font>任何二目、三目运算符的左右两边都需要加一个空格</p>
<p><font color='sienna'>说明：</font>运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等</p>
</li>
<li><p><font color='red'>【强制】</font>采用 4 个空格缩进，禁止使用 tab 字符</p>
<p><font color='sienna'>说明：</font>如果使用<code> tab</code> 缩进，必须设置 1 个 <code>tab</code> 为 4 个空格。<code>IDEA</code> 设置 tab 为 4 个空格时，请勿勾选 <code>Use tab character</code>（<a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/148a1921cbaaf04d71c3b1ee.html">扩展IDEA设置按TAB时输入四个空格的方法</a>）；而在 <code>eclipse</code> 中，必须勾选 <code>insert spaces for tabs</code></p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缩进 4 个空格</span></span><br><span class="line">    String say = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 运算符的左右必须有一个空格</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(say);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左大括号前加空格且不换行；左大括号后换行</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="comment">// 右大括号前换行，右大括号后有 else，不用换行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="comment">// 在右大括号后直接结束，则必须换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>注释的双斜线与注释内容之间有且仅有一个空格</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是示例注释，请注意在双斜线之后有一个空格</span></span><br><span class="line">String ygb = <span class="keyword">new</span> String();</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则</p>
<ul>
<li>第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例</li>
<li>运算符与下文一起换行</li>
<li>方法调用的点符号与下文一起换行</li>
<li>方法调用中的多个参数需要换行时，在逗号后进行</li>
<li>在括号前不要换行，见反例</li>
</ul>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行</span></span><br><span class="line">sb.append(<span class="string">&quot;zi&quot;</span>).append(<span class="string">&quot;xin&quot;</span>)</span><br><span class="line">    .append(<span class="string">&quot;huang&quot;</span>)</span><br><span class="line">    .append(<span class="string">&quot;huang&quot;</span>)</span><br><span class="line">    .append(<span class="string">&quot;huang&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，不要在括号前换行</span></span><br><span class="line">sb.append(<span class="string">&quot;zi&quot;</span>).append(<span class="string">&quot;xin&quot;</span>)...append</span><br><span class="line">(<span class="string">&quot;huang&quot;</span>);</span><br><span class="line"><span class="comment">// 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行</span></span><br><span class="line">method(args1, args2, args3, ...</span><br><span class="line">, argsX);</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>方法参数在定义和传入时，多个参数逗号后边必须加空格</p>
<p><font color='green'>正例：</font>下例中实参的<code>args1</code>，后边必须要有一个空格</p>
<p><code>method(args1, args2, args3);</code></p>
</li>
<li><p><font color='red'>【强制】</font><code>IDE</code> 的 <code>text file encoding</code> 设置为 <code>UTF-8</code>; <code>IDE</code> 中文件的换行符使用 <code>Unix</code> 格式，不要使用 <code>Windows</code>格式</p>
</li>
<li><p><font color='green'>【推荐】</font>单个方法的总行数不超过 80 行</p>
<p><font color='sienna'>说明：</font>包括方法签名、结束右大括号、方法内代码、注释、空行、回车及任何不可见字符的总行数不超过 80 行</p>
<p><font color='green'>正例：</font>代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护</p>
</li>
<li><p><font color='green'>【推荐】</font>没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> two = <span class="number">2L</span>;</span><br><span class="line"><span class="keyword">float</span> three = <span class="number">3F</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br></pre></td></tr></table></figure>

<p><font color='sienna'>说明：</font>增加 <code>sb</code> 这个变量，如果需要对齐，则给 <code>a、b、c</code> 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情</p>
</li>
<li><p><font color='green'>【推荐】</font>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性</p>
<p><font color='sienna'>说明：</font>任何情形，没有必要插入多个空行进行隔开</p>
</li>
</ol>
<h2 id="（四）OOP规约"><a href="#（四）OOP规约" class="headerlink" title="（四）OOP规约"></a>（四）OOP规约</h2><ol>
<li><p><font color='red'>【强制】</font>避免通过一个类的对象引用访问此类的<font color='red'>静态变量或静态方法</font>，无谓增加编译器解析成本，直接用<font color='blue'>类名</font>来访问即可</p>
</li>
<li><p><font color='red'>【强制】</font>所有的覆写方法，必须加<code>@Override</code> 注解</p>
<p><font color='sienna'>说明：</font><code>getObject()</code>与 <code>get0bject()</code>的问题。一个是字母的 O，一个是数字的 0，加<code>@Override</code>可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错</p>
</li>
<li><p><font color='red'>【强制】</font>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 <code>Object</code></p>
<p><font color='sienna'>说明：</font>可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUsers</span><span class="params">(String type, Long... ids)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加<code>@Deprecated</code> 注解，并清晰地说明采用的新接口或者新服务是什么</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJson</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> toJson(getAttributes(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>不能使用过时的类或方法</p>
<p><font color='sienna'>说明：</font><code>java.net.URLDecoder</code> 中的方法 <code>decode(String encodeStr)</code> 这个方法已经过时，应该使用双参数 <code>decode(String source, String encode)</code>。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么</p>
</li>
<li><p><font color='red'>【强制】</font><code>Object</code> 的 <code>equals</code>方法容易抛空指针异常，应使用常量或确定有值的对象来调用<code>equals</code></p>
<p><font color='green'>正例：</font><code>&quot;test&quot;.equals(object);</code></p>
<p><font color='orange'>反例：</font><code>object.equals(&quot;test&quot;)</code></p>
<p><font color='sienna'>说明：</font>推荐使用 <code>java.util.Objects#equals</code>（<code>JDK7</code> 引入的工具类）</p>
</li>
<li><p><font color='red'>【强制】</font>所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较</p>
<p><font color='sienna'>说明：</font>对于 <code>Integer var = ?</code> 在-128 至 127 范围内的赋值，<code>Integer</code> 对象是在<code>IntegerCache.cache</code> 产生，会复用已有对象，这个区间内的 <code>Integer</code> 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 <code>equals</code> 方法进行判断</p>
</li>
<li><p>关于基本数据类型与包装数据类型的使用标准如下</p>
<ul>
<li><font color='red'>【强制】</font>所有的 <code>POJO</code> 类属性必须使用包装数据类型</li>
<li><font color='red'>【强制】</font><code>RPC</code> 方法的返回值和参数必须使用包装数据类型</li>
<li><font color='green'>【推荐】</font>所有的局部变量使用基本数据类型</li>
</ul>
<p><font color='sienna'>说明：</font><code>POJO</code> 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何<code>NPE</code>(空指针异常)问题，或者入库检查，都由使用者来保证</p>
<p><font color='green'>正例：</font>数据库的查询结果可能是 <code>null</code>，因为自动拆箱，用基本数据类型接收有 <code>NPE</code> 风险</p>
<p><font color='orange'>反例：</font>比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 <code>RPC</code> 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出</p>
</li>
<li><p><font color='red'>【强制】</font>定义 <code>DO/DTO/VO</code> 等 <code>POJO </code>类时，不要设定任何属性默认值</p>
<p><font color='orange'>反例：</font><code>POJO</code> 类的 <code>gmtCreate</code> 默认值为 <code>new Date()</code>，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间</p>
</li>
<li><p><font color='red'>【强制】</font>序列化类新增属性时，请不要修改 <code>serialVersionUID</code> 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 <code>serialVersionUID</code> 值</p>
<p><font color='sienna'>说明：</font>注意 <code>serialVersionUID</code> 不一致会抛出序列化运行时异常</p>
</li>
<li><p><font color='red'>【强制】</font>构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中</p>
</li>
<li><p><font color='red'>【强制】</font><code>POJO</code> 类必须写<code> toString</code> 方法。使用 <code>IDE</code> 中的工具：<code>source&gt; generate toString</code>时，如果继承了另一个 <code>POJO</code> 类，注意在前面加一下 <code>super.toString</code></p>
<p><font color='sienna'>说明：</font>在方法执行抛出异常时，可以直接调用 <code>POJO</code> 的 <code>toString()</code>方法打印其属性值，便于排查问题</p>
</li>
<li><p><font color='red'>【强制】</font>禁止在 <code>POJO</code> 类中，同时存在对应属性 <code>xxx</code> 的 <code>isXxx()</code>和<code> getXxx()</code>方法</p>
<p><font color='sienna'>说明：</font>框架在调用属性 <code>xxx </code>的提取方法时，并不能确定哪个方法一定是被优先调用到</p>
</li>
<li><p><font color='green'>【推荐】</font>使用索引访问用 <code>String</code> 的 <code>split</code> 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 <code>IndexOutOfBoundsException</code> 的风险</p>
<p><font color='sienna'>说明：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;a,b,c,,&quot;</span>;</span><br><span class="line">String[] ary = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">// 预期大于 3，结果是 3</span></span><br><span class="line">System.out.println(ary.length);</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第 16 条规则</p>
</li>
<li><p><font color='green'>【推荐】</font>类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; <code>getter/setter</code>方法</p>
<p><font color='sienna'>说明：</font>公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 <code>Service</code> 和 <code>DAO</code> 的 <code>getter/setter</code> 方法放在类体最后</p>
</li>
<li><p><font color='green'>【推荐】</font><code>setter</code> 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在<code>getter/setter</code> 方法中，不要增加业务逻辑，增加排查问题的难度</p>
<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data + <span class="number">100</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data - <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>循环体内，字符串的连接方式，使用 <code>StringBuilder</code> 的 <code>append</code> 方法进行扩展</p>
<p><font color='sienna'>说明：</font>下例中，反编译出的字节码文件显示每次循环都会 new 出一个 <code>StringBuilder</code> 对象，然后进行 <code>append </code>操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/su-feng/p/6659064.html">扩展<code>Java</code>中的<code>String，StringBuilder，StringBuffer</code>三者的区别</a>)</p>
<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;start&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    str = str + <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字</p>
<ul>
<li>不允许被继承的类，如：<code>String</code> 类</li>
<li>不允许修改引用的域对象</li>
<li>不允许被重写的方法，如：<code>POJO</code> 类的 <code>setter</code> 方法</li>
<li>不允许运行过程中重新赋值的局部变量</li>
<li>避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构</li>
</ul>
</li>
<li><p><font color='green'>【推荐】</font>慎用 <code>Object</code> 的 <code>clone</code>方法来拷贝对象</p>
<p><font color='sienna'>说明：</font>对象的 <code>clone</code> 方法默认是浅拷贝，若想实现深拷贝需要重写 <code>clone</code> 方法实现域对象的深度遍历式拷贝</p>
</li>
<li><p><font color='green'>【推荐】</font>类成员与方法访问控制从严</p>
<ul>
<li>如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private</li>
<li>工具类不允许有 <code>public</code> 或 <code>default</code> 构造方法</li>
<li>类非 <code>static</code> 成员变量并且与子类共享，必须是 <code>protected</code></li>
<li>类非 <code>static </code>成员变量并且仅在本类使用，必须是 <code>private</code></li>
<li>类 <code>static</code> 成员变量如果仅在本类使用，必须是 <code>private</code></li>
<li>若是 <code>static </code>成员变量，考虑是否为 <code>final</code></li>
<li>类成员方法只供类内部调用，必须是 <code>private</code></li>
<li>类成员方法只对继承类公开，那么限制为 <code>protected</code></li>
</ul>
<p><font color='sienna'>说明：</font>任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个 <code>private</code> 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的</p>
</li>
</ol>
<h2 id="（五）集合处理"><a href="#（五）集合处理" class="headerlink" title="（五）集合处理"></a>（五）集合处理</h2><ol>
<li><p><font color='red'>【强制】</font>关于 <code>hashCode</code> 和 <code>equals </code>的处理，遵循如下规则</p>
<ul>
<li>只要重写 equals，就必须重写 <code>hashCode</code></li>
<li>因为 <code>Set</code> 存储的是不重复的对象，依据 <code>hashCode</code> 和 <code>equals</code> 进行判断，所以 <code>Set</code> 存储的对象必须重写这两个方法</li>
<li>如果自定义对象作为 Map 的键，那么必须重写 <code>hashCode</code> 和 <code>equals</code></li>
</ul>
<p><font color='sienna'>说明：</font><code>String </code>重写了 <code>hashCode</code> 和 <code>equals</code> 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用</p>
</li>
<li><p><font color='red'>【强制】</font><code>ArrayList</code>的<code>subList</code>结果不可强转成<code>ArrayList</code>，否则会抛出<code>ClassCastException</code>异常，即 <code>java.util.RandomAccessSubList cannot be cast to java.util.ArrayList</code></p>
<p><font color='sienna'>说明：</font><code>subList</code> 返回的是<code> ArrayList</code> 的内部类<code> SubList</code>，并不是 <code>ArrayList</code> 而是<code> ArrayList</code>的一个视图，对于 <code>SubList </code>子列表的所有操作最终会反映到原列表上</p>
</li>
<li><p><font color='red'>【强制】</font>在 <code>subList</code> 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 <code>ConcurrentModificationException</code> 异常</p>
</li>
<li><p><font color='red'>【强制】</font>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一样的数组，大小就是 <code>list.size()</code></p>
<p><font color='sienna'>说明：</font>使用<code> toArray</code> 带参方法，入参分配的数组空间不够大时，<code>toArray</code> 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="string">&quot;guan&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bao&quot;</span>);</span><br><span class="line">String[] array = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">array = list.toArray(array);</span><br></pre></td></tr></table></figure>

<p><font color='orange'>反例：</font>直接使用 <code>toArray</code> 无参方法存在问题，此方法返回值只能是 <code>Object[]</code>类，若强转其它类型数组将出现 <code>ClassCastException</code> 错误</p>
</li>
<li><p><font color='red'>【强制】</font>使用工具类 <code>Arrays.asList()</code>把数组转换成集合时，不能使用其修改集合相关的方法，它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常</p>
<p><font color='sienna'>说明：</font><code>asList</code> 的返回对象是一个 <code>Arrays</code> 内部类，并没有实现集合的修改方法。<code>Arrays.asList</code>体现的是适配器模式，只是转换接口，后台的数据仍是数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;you&quot;</span>, <span class="string">&quot;wu&quot;</span> &#125;;</span><br><span class="line">List list = Arrays.asList(str)</span><br></pre></td></tr></table></figure>

<p>第一种情况：<code>list.add(&quot;yangguanbao&quot;);</code> 运行时异常</p>
<p>第二种情况：<code>str[0] = &quot;gujin&quot;;</code> 那么 <code>list.get(0)</code>也会随之修改</p>
</li>
<li><p><font color='red'>【强制】</font>泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据，此写法的泛型集合不能使用 <code>add</code> 方法，而<code>&lt;? super T&gt;</code>不能使用 <code>get</code> 方法，作为接口调用赋值时易出错</p>
<p><font color='sienna'>说明：</font>扩展说一下 <code>PECS(Producer Extends Consumer Super)</code>原则：第一、频繁往外读取内容的，适合用<code>&lt;? extends T&gt;</code>。第二、经常往里插入的，适合用<code>&lt;? super T&gt;</code></p>
</li>
<li><p><font color='red'>【强制】</font>不要在 <code>foreach</code> 循环里进行元素的 <code>remove/add</code> 操作。<code>remove</code> 元素请使用 <code>Iterator</code>方式，如果并发操作，需要对 Iterator 对象加锁</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String item = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (删除元素的条件) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(item)) &#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='sienna'>说明：</font>以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗</p>
</li>
<li><p><font color='red'>【强制】</font>在 <code>JDK7</code> 版本及以上，<code>Comparator</code>（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rossoneri/p/4549529.html">扩展Java] 用 Comparator 实现排序</a>） 实现类要满足如下三个条件，不然<code> Arrays.sort</code>，<code>Collections.sort</code> 会报 <code>IllegalArgumentException</code> 异常</p>
<p><font color='sienna'>说明：</font>三个条件如下</p>
<ul>
<li>x，y 的比较结果和 y，x 的比较结果相反</li>
<li>x&gt;y，y&gt;z，则 x&gt;z</li>
<li>x=y，则 x，z 比较结果和 y，z 比较结果相同</li>
</ul>
<p><font color='orange'>反例：</font>下例中没有处理相等的情况，实际使用中可能会出现异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() &gt; o2.getId() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>集合泛型定义时，在 <code>JDK7</code> 及以上，使用 <code>diamond</code> 语法或全省略</p>
<p><font color='sienna'>说明：</font>菱形泛型，即 <code>diamond</code>，直接使用&lt;&gt;来指代前边已经指定的类型</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;&gt; diamond 方式</span></span><br><span class="line">HashMap&lt;String, String&gt; userCache = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 全省略方式</span></span><br><span class="line">ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>集合初始化时，指定集合初始值大小</p>
<p><font color='sienna'>说明：</font><code>HashMap </code>使用 <code>HashMap(int initialCapacity) </code>初始化</p>
<p><font color='green'>正例：</font><code>initialCapacity</code> = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 <code>loader factor</code>）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。反例：<code>HashMap</code> 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，<code>resize</code> 需要重建 <code>hash</code> 表，严重影响性能</p>
</li>
<li><p><font color='green'>【推荐】</font>使用 <code>entrySet</code> 遍历 <code>Map</code> 类集合 <code>KV</code>，而不是 <code>keySet</code> 方式进行遍历</p>
<p><font color='sienna'>说明：</font><code>keySet</code> 其实是遍历了 2 次，一次是转为 <code>Iterator</code> 对象，另一次是从 <code>hashMap </code>中取出<code>key</code> 所对应的 <code>value</code>。而 <code>entrySet</code> 只是遍历了一次就把 <code>key</code> 和 <code>value</code> 都放到了 <code>entry</code> 中，效率更高。如果是 <code>JDK8</code>，使用 <code>Map.foreach</code> 方法</p>
<p><font color='green'>正例：</font><code>values()</code>返回的是 V 值集合，是一个 <code>list</code> 集合对象；<code>keySet()</code>返回的是 K 值集合，是一个 Set 集合对象；<code>entrySet()</code>返回的是 K-V 值组合集合</p>
</li>
<li><p><font color='green'>【推荐】</font>高度注意 <code>Map</code> 类集合<code>K/V</code>能不能存储<code> null</code> 值的情况，如下表格</p>
<table>
<thead>
<tr>
<th>集合类</th>
<th>Key</th>
<th>Value</th>
<th>Super</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Hashtable</td>
<td><font color='red'>不允许为 null</font></td>
<td><font color='red'>不允许为 null</font></td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td><font color='red'>不允许为 null</font></td>
<td><font color='red'>不允许为 null</font></td>
<td>AbstractMap</td>
<td>锁分段技术（JDK8:CAS）</td>
</tr>
<tr>
<td>TreeMap</td>
<td><font color='red'>不允许为 null</font></td>
<td><font color='blue'>允许为 null</font></td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>HashMap</td>
<td><font color='blue'>允许为 null</font></td>
<td><font color='blue'>允许为 null</font></td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<p><font color='orange'>反例：</font>由于 <code>HashMap</code> 的干扰，很多人认为 <code>ConcurrentHashMap</code> 是可以置入 <code>null</code> 值，而事实上，存储 <code>null</code> 值时会抛出 <code>NPE</code> 异常</p>
</li>
<li><p><font color='green'>【推荐】</font>合理利用好集合的有序性(<code>sort</code>)和稳定性(<code>order</code>)，避免集合的无序性(<code>unsort</code>)和不稳定性(<code>unorder</code>)带来的负面影响</p>
<p><font color='sienna'>说明：</font>有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：<code>ArrayList</code> 是 <code>order/unsort</code>；<code>HashMap</code> 是 <code>unorder/unsort</code>；<code>TreeSet</code> 是<code>order/sort</code></p>
</li>
<li><p><font color='green'>【推荐】</font>利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List </code>的<code>contains</code> 方法进行遍历、对比、去重操作</p>
</li>
</ol>
<h2 id="（六）并发处理"><a href="#（六）并发处理" class="headerlink" title="（六）并发处理"></a>（六）并发处理</h2><ol>
<li><p><font color='red'>【强制】</font>获取单例对象需要保证线程安全，其中的方法也要保证线程安全</p>
<p><font color='sienna'>说明：</font>资源驱动类、工具类、单例工厂类都需要注意</p>
</li>
<li><p><font color='red'>【强制】</font>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">&quot;TimerTaskThread&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3932921.html">扩展Java并发编程：线程池的使用</a>）</p>
<p><font color='sienna'>说明：</font>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</p>
</li>
<li><p><font color='red'>【强制】</font>线程池不允许使用 Executors 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p><font color='sienna'>说明：</font><code>Executors </code>返回的线程池对象的弊端如下</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>:允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 <code>OOM</code></li>
<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>:允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致 <code>OOM</code></li>
</ul>
</li>
<li><p><font color='red'>【强制】</font><code>SimpleDateFormat</code> 是线程不安全的类，一般不要定义为 <code>static</code> 变量，如果定义为<code>static</code>，必须加锁，或者使用 <code>DateUtils</code> 工具类</p>
<p><font color='green'>正例：</font>注意线程安全，使用 <code>DateUtils</code>。亦推荐如下处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font color='sienna'>说明：</font>如果是 <code>JDK8</code> 的应用，可以使用 <code>Instant</code> 代替 <code>Date</code>，<code>LocalDateTime</code> 代替 <code>Calendar</code>，<code>DateTimeFormatter</code> 代替 <code>SimpleDateFormat</code>，官方给出的解释：<code>simple beautiful strong immutable thread-safe</code></p>
</li>
<li><p><font color='red'>【强制】</font>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁</p>
<p><font color='sienna'>说明：</font>尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 <code>RPC</code> 方法</p>
</li>
<li><p><font color='red'>【强制】</font>对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁</p>
<p><font color='sienna'>说明：</font>线程一需要对表 <code>A、B、C</code> 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 <code>A、B、C</code>，否则可能出现死锁</p>
</li>
<li><p><font color='red'>【强制】</font>并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 <code>version</code> 作为更新依据</p>
<p><font color='sienna'>说明：</font>如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次</p>
</li>
<li><p><font color='red'>【强制】</font>多线程并行处理定时任务时，<code>Timer </code>运行多个 <code>TimeTask</code> 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 <code>ScheduledExecutorService</code>则没有这个问题</p>
</li>
<li><p><font color='red'>【强制】</font>禁止在循环中调用<code>synchronized</code>（同步）方法</p>
<p><font color='sienna'>说明：</font>方法的同步需要消耗相当大的资源，不要在循环中调用同步方法</p>
<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SYN</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            method (vector.elementAt(i));    <span class="comment">// violation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Vector vector = <span class="keyword">new</span> Vector (<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SYN</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>&#123;<span class="comment">//在一个同步块中执行非同步方法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                method (vector.elementAt(i));   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Vector vector = <span class="keyword">new</span> Vector (<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>禁止在循环中使用表达式</p>
<p><font color='sienna'>说明：</font>在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快</p>
<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">(Vector vector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size (); i++)  <span class="comment">// Violation</span></span><br><span class="line">            ; <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEL_fixed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">(Vector vector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = vector.size ()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            ; <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>使用 <code>CountDownLatch</code> 进行异步转同步操作，每个线程退出前必须调用 <code>countDown</code>方法，线程执行代码注意 <code>catch</code> 异常，确保<code> countDown</code> 方法被执行到，避免主线程无法执行至 <code>await</code> 方法，直到超时才返回结果</p>
<p><font color='sienna'>说明：</font>注意，子线程抛出异常堆栈，不能在主线程 try-catch 到</p>
</li>
<li><p><font color='green'>【推荐】</font>避免 <code>Random</code> 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一<code>seed</code> 导致的性能下降（<a target="_blank" rel="noopener" href="http://www.importnew.com/12460.html">扩展多线程下生成随机数</a>）</p>
<p><font color='sienna'>说明：</font><code>Random</code> 实例包括 <code>java.util.Random</code> 的实例或者 <code>Math.random()</code>的方式</p>
<p><font color='green'>正例：</font>在 <code>JDK7</code> 之后，可以直接使用<code> API ThreadLocalRandom</code>，而在 <code>JDK7 </code>之前，需要编码保证每个线程持有一个实例</p>
</li>
<li><p><font color='green'>【推荐】</font>在并发场景下，通过双重检查锁（<code>double-checked locking</code>）实现延迟初始化的优化问题隐患(可参考 The “<code>Double-Checked Locking is Broken&quot; Declaration</code>)，推荐解决方案中较为简单一种（适用于 <code>JDK5</code> 及以上版本），将目标属性声明为 <code>volatile</code> 型</p>
<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyInitDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">                helper = <span class="keyword">new</span> Helper();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// other methods and fields...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="（七）控制语句"><a href="#（七）控制语句" class="headerlink" title="（七）控制语句"></a>（七）控制语句</h2><ol>
<li><p><font color='red'>【强制】</font>在一个 <code>switch</code> 块内，每个 <code>case</code> 要么通过 <code>break/return</code> 等来终止，要么注释说明程序将继续执行到哪一个 <code>case</code> 为止；在一个 <code>switch</code> 块内，都必须包含一个 <code>default</code> 语句并且放在最后，即使空代码</p>
</li>
<li><p><font color='red'>【强制】</font>在高并发场景中，避免使用”等于”判断作为中断或退出的条件</p>
<p><font color='sienna'>说明：</font>如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替</p>
<p><font color='orange'>反例：</font>判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止</p>
</li>
<li><p><font color='red'>【强制】</font>在 <code>if/else/for/while/do</code>语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：<code>if (condition) statements</code></p>
</li>
<li><p><font color='green'>【推荐】</font>表达异常的分支时，少用 if-else 方式，这种方式可以改写成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line"> ...</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 接着写 else 的业务逻辑代码;</span></span><br></pre></td></tr></table></figure>

<p><font color='sienna'>说明：</font>如果非得使用 <code>if()...else if()...else...</code>方式表达逻辑，<font color='red'>【强制】</font>避免后续代码维护困难，请勿超过 3 层</p>
<p><font color='green'>正例：</font>超过 3 层的 <code>if-else</code> 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">today</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBusy()) &#123;</span><br><span class="line">        System.out.println(“change time.”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFree()) &#123;</span><br><span class="line">        System.out.println(“go to travel.”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>除常用方法（如<code>getXxx/isXxx</code>等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性</p>
<p><font color='sienna'>说明：</font>很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码如下</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">&quot;w&quot;</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);</span><br><span class="line"><span class="keyword">if</span> (existed) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((file.open(fileName, <span class="string">&quot;w&quot;</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...)) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 <code>try-catch</code> 操作（这个 <code>try-catch</code> 是否可以移至循环体外）</p>
</li>
<li><p><font color='green'>【推荐】</font>避免采用取反逻辑运算符</p>
<p><font color='sienna'>说明：</font>取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法</p>
<p><font color='green'>正例：</font>使用<code>if (x &lt; 628)</code>来表达 <code>x</code> 小于 628</p>
<p><font color='orange'>反例：</font>使用 if (!(x &gt;= 628)) 来表达 x 小于 628</p>
</li>
<li><p><font color='green'>【推荐】</font>接口入参保护，这种场景常见的是用作批量操作的接口</p>
</li>
<li><p><font color='green'>【推荐】</font>下列情形，需要进行参数校验：</p>
<ul>
<li>调用频次低的方法</li>
<li>执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失</li>
<li>需要极高稳定性和可用性的方法</li>
<li>对外提供的开放接口，不管是 <code>RPC/API/HTTP</code> 接口</li>
<li>敏感权限入口</li>
</ul>
</li>
<li><p><font color='green'>【推荐】</font>下列情形，不需要进行参数校验</p>
<ul>
<li>极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求</li>
<li>底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般<code>DAO</code>层与 <code>Service</code> 层都在同一个应用中，部署在同一台服务器中，所以 <code>DAO </code>的参数校验，可以省略</li>
<li>被声明成 <code>private</code> 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数</li>
</ul>
</li>
</ol>
<h2 id="（八）注释规约"><a href="#（八）注释规约" class="headerlink" title="（八）注释规约"></a>（八）注释规约</h2><ol>
<li><p><font color='red'>【强制】</font>类、类属性、类方法的注释必须使用 <code>Javadoc</code> 规范，使用/**内容*/格式，不得使用// xxx 方式</p>
<p><font color='sienna'>说明：</font>在 <code>IDE</code> 编辑窗口中，<code>Javadoc</code> 方式会提示相关注释，生成 <code>Javadoc</code> 可以正确输出相应注释；在 <code>IDE</code> 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率</p>
</li>
<li><p><font color='red'>【强制】</font>所有的抽象方法（包括接口中的方法）必须要用 <code>Javadoc</code> 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</p>
<p><font color='sienna'>说明：</font>对子类的实现要求，或者调用注意事项，请一并说明</p>
</li>
<li><p><font color='red'>【强制】</font>所有的类都必须添加创建者和创建日期</p>
</li>
<li><p><font color='red'>【强制】</font>方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐</p>
</li>
<li><p><font color='red'>【强制】</font>所有的枚举类型字段必须要有注释，说明每个数据项的用途</p>
</li>
<li><p><font color='green'>【推荐】</font>与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可</p>
<p><font color='orange'>反例：</font>“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋</p>
</li>
<li><p><font color='green'>【推荐】</font>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改</p>
<p><font color='sienna'>说明：</font>代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义</p>
</li>
<li><p><font color='green'>【推荐】</font>谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除</p>
<p><font color='sienna'>说明：</font>代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）</p>
</li>
<li><p><font color='green'>【推荐】</font>特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码</p>
<ul>
<li><p>待办事宜（<code>TODO</code>）:（ 标记人，标记时间，[预计处理时间]）</p>
<p>表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc<br>还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）</p>
</li>
<li><p>错误，不能工作（<code>FIXME</code>）:（标记人，标记时间，[预计处理时间]）</p>
<p>在注释中用 <code>FIXME</code> 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p>
</li>
</ul>
</li>
<li><p><font color='green'>【推荐】</font>核心代码注释量不得低于文件总行数的30%，非核心代码注释量不得低于文件总行数的20%</p>
</li>
</ol>
<h2 id="（九）其他"><a href="#（九）其他" class="headerlink" title="（九）其他"></a>（九）其他</h2><ol>
<li><p><font color='red'>【强制】</font>在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度</p>
<p><font color='sienna'>说明：</font>不要在方法体内定义：Pattern pattern = Pattern.compile(“规则”)</p>
</li>
<li><p><font color='red'>【强制】</font><code>velocity</code> 调用 <code>POJO</code> 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 <code>POJO</code> 的 <code>getXxx()</code>，如果是<code> boolean</code> 基本数据类型变量（<code>boolean</code> 命名不需要加 <code>is</code>前缀），会自动调用 <code>isXxx()</code>方法</p>
<p><font color='sienna'>说明：</font>注意如果是 <code>Boolean</code> 包装类对象，优先调用 <code>getXxx()</code>的方法</p>
</li>
<li><p><font color='red'>【强制】</font>注意 <code>Math.random()</code> 这个方法返回是 <code>double</code> 类型，注意取值的范围 <code>0≤x&lt;1</code>（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 <code>Random</code> 对象的 <code>nextInt</code> 或者 <code>nextLong</code> 方法</p>
</li>
<li><p><font color='red'>【强制】</font>获取当前毫秒数 <code>System.currentTimeMillis()</code>; 而不是 <code>new Date().getTime()</code></p>
<p><font color='sienna'>说明：</font>如果想获取更加精确的纳秒级时间值，使用 <code>System.nanoTime()</code>的方式。在 <code>JDK8</code> 中，针对统计时间等场景，推荐使用 Instant 类</p>
</li>
<li><p><font color='red'>【强制】</font>删除未引用类，避免使用以”.*”结尾的引用，引用的顺序如下：</p>
<ul>
<li><code>JDK</code>标准包（例如：<code>import java.io.IOException</code>等）</li>
<li>第三方的包（例如：<code>import org.dom4j.Node</code>等）</li>
<li>项目的公共包</li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>禁止在循环体中生命并实例化变量</p>
<p><font color='sienna'>说明：</font>在循环体中声明并实例化临时变量将会增加内存消耗，增加垃圾回收的次数；尤其是大对象，严格禁止在循环体内声明并实例化对象</p>
<p><font color='orange'>反例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LOOP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">(Vector v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; v.size();i++) &#123;</span><br><span class="line">            Object o = <span class="keyword">new</span> Object(); <span class="comment">// 不建议</span></span><br><span class="line">            o = v.elementAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='green'>正例：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LOOP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span> <span class="params">(Vector v)</span> </span>&#123;</span><br><span class="line">        Object o;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++) &#123;</span><br><span class="line">            o = v.elementAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>不要在视图模板中加入任何复杂的逻辑</p>
<p><font color='sienna'>说明：</font>根据 <code>MVC </code>理论，视图的职责是展示，不要抢模型和控制器的活</p>
</li>
<li><p><font color='green'>【推荐】</font>任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存</p>
</li>
<li><p><font color='green'>【推荐】</font>及时清理不再使用的代码段或配置信息</p>
<p><font color='sienna'>说明：</font>对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余</p>
<p><font color='green'>正例：</font>对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由</p>
</li>
</ol>
<h1 id="二、异常日志"><a href="#二、异常日志" class="headerlink" title="二、异常日志"></a>二、异常日志</h1><h2 id="（一）异常处理"><a href="#（一）异常处理" class="headerlink" title="（一）异常处理"></a>（一）异常处理</h2><ol>
<li><p><font color='red'>【强制】</font><code>Java</code> 类库中定义的可以通过预检查方式规避的 <code>RuntimeException</code>异常不应该通过<br><code>catch</code> 的方式来处理，比如：<code>NullPointerException</code>，<code>IndexOutOfBoundsException</code> 等等</p>
<p><font color='sienna'>说明：</font>无法通过预检查的异常除外，比如，在解析字符串形式的数字时，不得不通过 <code>catch NumberFormatException</code> 来实现</p>
<p><font color='green'>正例：</font><code>if (obj != null) &#123;...&#125;</code></p>
<p><font color='orange'>反例：</font><code>try &#123; obj.method(); &#125; catch (NullPointerException e) &#123;…&#125;</code></p>
</li>
<li><p><font color='red'>【强制】</font>异常不要用来做流程控制，条件控制</p>
<p><font color='sienna'>说明：</font>异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多</p>
</li>
<li><p><font color='red'>【强制】</font>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理</p>
<p><font color='sienna'>说明：</font>对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现</p>
<p><font color='green'>正例：</font>用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户</p>
</li>
<li><p><font color='red'>【强制】</font>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容</p>
</li>
<li><p><font color='red'>【强制】</font>有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务</p>
</li>
<li><p><font color='red'>【强制】</font>finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch</p>
<p><font color='sienna'>说明：</font>如果 <code>JDK7</code> 及以上，可以使用 <code>try-with-resources</code> 方式（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/itZhy/p/7636615.html">扩展Java进阶知识点3：更优雅地关闭资源 - try-with-resource及其异常抑制</a>）</p>
</li>
<li><p><font color='red'>【强制】</font>不要在 finally 块中使用 return</p>
<p><font color='sienna'>说明：</font>finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句</p>
</li>
<li><p><font color='red'>【强制】</font>捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类</p>
<p><font color='sienna'>说明：</font>如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况</p>
</li>
<li><p><font color='green'>【推荐】</font>方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值</p>
<p><font color='sienna'>说明：</font>本手册明确防止 <code>NPE</code> 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null 的情况</p>
</li>
<li><p><font color='red'>【强制】</font>防止 <code>NPE</code>，是程序员的基本修养，注意 <code>NPE</code> 产生的场景</p>
<ul>
<li><p>返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 <code>NPE</code></p>
<p><font color='orange'>反例：</font><code>public int f() &#123; return Integer 对象&#125;</code>， 如果为 null，自动解箱抛 <code>NPE</code></p>
</li>
<li><p>数据库的查询结果可能为 null</p>
</li>
<li><p>集合里的元素即使 <code>isNotEmpty</code>，取出的数据元素也可能为 null</p>
</li>
<li><p>远程调用返回对象时，一律要求进行空指针判断，防止 <code>NPE</code></p>
</li>
<li><p>对于 Session 中获取的数据，建议 <code>NPE</code> 检查，避免空指针</p>
</li>
<li><p>级联调用 <code>obj.getA().getB().getC()</code>；一连串调用，易产生 <code>NPE</code></p>
<p><font color='green'>正例：</font>使用<code> JDK8</code> 的 <code>Optional</code> 类来防止 <code>NPE</code> 问题。（<a target="_blank" rel="noopener" href="http://www.importnew.com/26066.html">扩展Java8 如何正确使用 Optional</a>）</p>
</li>
</ul>
</li>
<li><p><font color='green'>【推荐】</font>定义时区分 unchecked / checked 异常，避免直接抛出 <code>new RuntimeException()</code>，更不允许抛出 <code>Exception</code> 或者 <code>Throwable</code>，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：<code>DAOException / ServiceException</code> 等</p>
</li>
<li><p><font color='green'>【推荐】</font>对于公司外的 <code>http/api </code>开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 <code>RPC</code> 调用优先考虑使用 <code>Result</code> 方式，封装 <code>isSuccess()</code>方法、“错误码”、“错误简短信息”</p>
<p><font color='sienna'>说明：</font>关于 <code>RPC</code> 方法返回方式使用 Result 方式的理由</p>
<ul>
<li>使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误</li>
<li>如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题</li>
</ul>
</li>
<li><p><font color='green'>【推荐】</font>避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则</p>
<p><font color='sienna'>说明：</font>随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化</p>
<p><font color='green'>正例：</font>一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br><code>private boolean checkParam(DTO dto) &#123;...&#125; </code></p>
</li>
</ol>
<h2 id="（二）日志规约"><a href="#（二）日志规约" class="headerlink" title="（二）日志规约"></a>（二）日志规约</h2><ol>
<li><p><font color='red'>【强制】</font>应用中不可直接使用日志系统（<code>Log4j、Logback</code>）中的 <code>API</code>，而应依赖使用日志框架<code>SLF4J</code> 中的<code> API</code>，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Abc.class);</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点</p>
</li>
<li><p><font color='red'>【强制】</font>应用中的扩展日志（如打点、临时监控、访问日志等）命名方式</p>
<p><code>appName_logType_logName.log</code></p>
<p><code>logType:</code>日志类型，如 <code>stats/monitor/access</code> 等；<code>logName:</code>日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找</p>
<p><font color='green'>正例：</font><code>mppserver</code> 应用中单独监控时区转换异常，如：</p>
<p><code>mppserver_monitor_timeZoneConvert.log</code></p>
<p><font color='sienna'>说明：</font>推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控</p>
</li>
<li><p><font color='red'>【强制】</font>对 <code>trace/debug/info</code> 级别的日志输出，必须使用条件输出形式或者使用占位符的方式</p>
<p><font color='sienna'>说明：</font><code>logger.debug(&quot;Processing trade with id: &quot; + id + &quot; and symbol: &quot; + symbol);</code>如果日志级别是 <code>warn</code>，上述日志不会打印，但是会执行字符串拼接操作，如果 <code>symbol</code> 是对象，会执行 <code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印</p>
<p><font color='green'>正例：</font>（条件）建设采用如下方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">	logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='green'>正例：</font>（占位符）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &#123;&#125; and symbol : &#123;&#125; &quot;</span>, id, symbol);</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>避免重复打印日志，浪费磁盘空间，务必在 <code>log4j.xml </code>中设置 <code>additivity=false</code>。</p>
<p><font color='green'>正例：</font><code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></p>
</li>
<li><p><font color='red'>【强制】</font>异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 <code>throws</code> 往上抛出</p>
<p><font color='green'>正例：</font><code>logger.error(各类参数或者对象 toString() + &quot;_&quot; + e.getMessage(), e);</code></p>
</li>
<li><p><font color='green'>【推荐】</font>可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从</p>
</li>
</ol>
<h1 id="三、安全规约"><a href="#三、安全规约" class="headerlink" title="三、安全规约"></a>三、安全规约</h1><ol>
<li><p><font color='red'>【强制】</font>用户输入的 <code>SQL</code> 参数严格使用参数绑定或者 <code>METADATA</code> 字段值限定，防止 <code>SQL</code> 注入，禁止字符串拼接 <code>SQL</code> 访问数据库</p>
</li>
<li><p><font color='red'>【强制】</font>用户请求传入的任何参数必须做有效性验证</p>
<p><font color='sienna'>说明：</font>忽略参数校验可能导致</p>
<ul>
<li>page size 过大导致内存溢出</li>
<li>恶意 order by 导致数据库慢查询</li>
<li>任意重定向</li>
<li><code>SQL</code> 注入</li>
<li>反序列化注入</li>
<li>正则输入源串拒绝服务 <code>ReDoS</code></li>
</ul>
<p><font color='sienna'>说明：</font>Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果</p>
</li>
<li><p><font color='red'>【强制】</font>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据</p>
</li>
<li><p><font color='red'>【强制】</font>表单、AJAX 提交必须执行 <code>CSRF</code> 安全验证</p>
</li>
<li><p><font color='red'>【强制】</font>在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机<br>制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</p>
</li>
</ol>
<h1 id="四、MySQL数据库"><a href="#四、MySQL数据库" class="headerlink" title="四、MySQL数据库"></a>四、MySQL数据库</h1><h2 id="（一）建表规约"><a href="#（一）建表规约" class="headerlink" title="（一）建表规约"></a>（一）建表规约</h2><ol>
<li><p><font color='red'>【强制】</font>表达是与否概念的字段，必须使用<code>is_xxx</code>的方式命名，数据类型是<code>unsigned tinyint</code>（1表示是，0表示否）</p>
<p><font color='sienna'>说明：</font>任何字段如果是非负数，必须是<code>unsigned</code></p>
<p><font color='red'>注意：</font><code>POJO</code>类中任何布尔类型的变量，都不要加is前缀，所以，需要在<resultMap>设置从<code>is_xxx</code>到<code>Xxx</code>的映射关系。数据库表示是与否的值，使用<code>tinyint</code>类型，坚持<code>is_xxx</code>的命名方式是为了明确其取之含义与取值范围</p>
<p><font color='green'>正例：</font>表达逻辑删除的字段名<code>is_deleted</code>，1表示删除，0表示未删除</p>
</li>
<li><p><font color='red'>【强制】</font>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
<p><font color='sienna'>说明：</font><code>MySQL</code>在<code>Windows</code>下不区分大小写，单在<code>Linux</code>下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。</p>
<p><font color='green'>正例：</font><code>aliyun_admin</code>，<code>rdc_config</code>，<code>level3_name</code></p>
<p><font color='orange'>反例：</font><code>AliyunAdmin</code>，<code>rdConfig</code>，<code>level_3_name</code></p>
</li>
<li><p><font color='red'>【强制】</font>表名不适用复数名词</p>
<p><font color='sienna'>说明：</font>表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。</p>
</li>
<li><p><font color='red'>【强制】</font>禁用保留字，如<code>desc</code>、<code>range</code>、<code>match</code>、<code>delayed</code>等，请参照<code>MySQL</code>官方保留字</p>
</li>
<li><p><font color='red'>【强制】</font>主键索引名为<code>pk_字段名</code>；唯一索引名为<code>uk_字段名</code>；普通索引名为<code>idx_字段名</code>。</p>
<p><font color='sienna'>说明：</font><code>pk_</code>即<code>primary key</code>；<code>uk_</code>即<code>unique key</code>;<code>idx_</code>即<code>index</code>的简称。</p>
</li>
<li><p><font color='red'>【强制】</font>小数类型为<code>decimal</code>，禁止使用<code>float</code>和<code>double</code></p>
<p><font color='sienna'>说明：</font><code>float</code>和<code>double</code>在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成证书和小数部分分开存储。</p>
</li>
<li><p><font color='red'>【强制】</font>如果存储的字符串长度几乎相等，使用<code>char</code>定长字符串类型</p>
</li>
<li><p><font color='red'>【强制】</font><code>varchar</code>是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出一张表，用主键来对应，避免影响其他字段索引效率。</p>
</li>
<li><p><font color='red'>【强制】</font>表必备三个字段：<code>id</code>，<code>gmt_create</code>，<code>gmt_modified</code></p>
<p><font color='sienna'>说明：</font>其中<code>id</code>必为主键，类型为<code>bigint unsigned</code>、表单时自增，步长为1。<code>gmt_create</code>，<code>gmt_modified</code>的类型均为<code>datetime</code>类型，前者现在时表示主动创建，后者过去分词表示被动更新</p>
</li>
<li><p><font color='green'>【推荐】</font>表的命名最好是“业务名称_表的作用”</p>
<p><font color='green'>正例：</font><code>alipay_task/force_project/trade_config</code></p>
</li>
<li><p><font color='green'>【推荐】</font>库名尽量与应用名保持一致</p>
</li>
<li><p><font color='green'>【推荐】</font>字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p>
<ul>
<li>不是频繁修改的字段</li>
<li>不是<code>varchar</code>超长字段，更不能是<code>text</code>字段</li>
</ul>
<p><font color='green'>正例：</font>商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p>
</li>
<li><p><font color='green'>【推荐】</font>单表行数超过500万行或者单表容量超过<code>2GB</code>，才推荐进行分库分表</p>
<p><font color='sienna'>说明：</font>如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
</li>
<li><p><font color='green'>【参考】</font>合适的字符存储长度，不但节约数据库表空间，节约索引存储，更重要的是提升检索速度</p>
<p><font color='green'>正例：</font>如下表，其中无符号值可以避免误存负数，且扩大了表示范围</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>年龄区间</th>
<th>类型</th>
<th>字节</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>人</td>
<td>150岁之内</td>
<td><code>tinyint unsigned</code></td>
<td>1</td>
<td>无符号：0~255</td>
</tr>
<tr>
<td>龟</td>
<td>数百岁</td>
<td><code>smallint unsigned</code></td>
<td>2</td>
<td>无符号：0~65535</td>
</tr>
<tr>
<td>恐龙化石</td>
<td>数千万年</td>
<td><code>int unsigned</code></td>
<td>4</td>
<td>无符号：0~约42.9亿</td>
</tr>
<tr>
<td>太阳</td>
<td>约50亿年</td>
<td><code>bigint unsigned</code></td>
<td>8</td>
<td>无符号：0~10的19次方</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="（二）索引规约"><a href="#（二）索引规约" class="headerlink" title="（二）索引规约"></a>（二）索引规约</h2><ol>
<li><p><font color='red'>【强制】</font>业务上具有唯一特性的字段，及时是多个字段的组合，也必须建成唯一索引</p>
<p><font color='sienna'>说明：</font>不要以为唯一索引影响了<code>insert</code>速度，这个速度损耗可以忽略，但提高了查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生</p>
</li>
<li><p><font color='red'>【强制】</font>超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。</p>
<p><font color='sienna'>说明：</font>即使双标join也要注意表索引和SQL性能</p>
</li>
<li><p><font color='red'>【强制】</font>在<code>varchar</code>字段上建立索引时，必须制定索引长度，没必要对全字段建立索引，根据实际文本区分度决定长度即可。</p>
<p><font color='sienna'>说明：</font>索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会打到90%以上，可以使用<code>count(distinct left(列名，索引长度))/count(*)</code>的区分度来确定.</p>
</li>
<li><p><font color='red'>【强制】</font>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决</p>
<p><font color='sienna'>说明：</font>索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</li>
<li><p><font color='green'>【推荐】</font>如果有order by的场景，请注意利用索引的有序性。order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。</p>
<p><font color='green'>正例：</font><code>where a=? and b=? order by c;</code> 索引：<code>a_b_c</code></p>
<p><font color='orange'>反例：</font>索引中有范围查找，那么索引有序性无法利用，如：<code>WHERE a&gt;10 ORDER BY b;</code>索引a_b无法排序</p>
</li>
<li><p><font color='green'>【推荐】</font>利用覆盖索引来进行查询操作，避免全表。</p>
<p><font color='sienna'>说明：</font>如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。</p>
<p><font color='green'>正例：</font>能够建立索引的中类分别为朱建索引、唯一索引、普通索引三种，而覆盖索引知识一种查询的一种效果，用<code>explain</code>的结果，<code>extra</code>列会出现<code>using index</code></p>
</li>
<li><p><font color='green'>【推荐】</font>利用延迟关联或者子查询优化超多分页场景</p>
<p><font color='sienna'>说明：</font><code>MySQL</code>并不是跳过<code>offset</code>行，而是取<code>offset+N</code>行，然后返回放弃前<code>offset</code>行，返回N行，那当<code>offset</code>特别大的时候，效率就非常的地下，要么控制返回的总页数，要么对超过特定阈值的页数进行<code>SQL</code>改写。</p>
<p><font color='green'>正例：</font>先快速定位需要获取的<code>id</code>段，然后再关联</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span> <span class="keyword">FROM</span> 表 <span class="number">1</span> a, (<span class="keyword">select</span> id <span class="keyword">from</span> 表 <span class="number">1</span> <span class="keyword">where</span> 条件 LIMIT <span class="number">100000</span>,<span class="number">20</span> ) b <span class="keyword">where</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【推荐】</font>防止因字段类型不同造成隐式转换，导致索引失效</p>
</li>
<li><p><font color='green'>【参考】</font>创建索引避免有如下极端误解</p>
<ul>
<li>宁滥勿缺：任务一个查询就需要建一个索引</li>
<li>宁缺毋滥：认为索引会小号控件、严重拖慢更新和新增速度</li>
<li>地址唯一索引：任务业务的唯一性一律需要在应用层通过“先查后插”方式解决</li>
</ul>
</li>
</ol>
<h2 id="（三）SQL语句"><a href="#（三）SQL语句" class="headerlink" title="（三）SQL语句"></a>（三）SQL语句</h2><ol>
<li><p><font color='red'>【强制】</font>不要使用<code>count(列名)</code>或者<code>count(常量)</code>来代替<code>count(\*)</code>,<code>count(*)</code>是<code>SQL92</code>定义的标准统计行数的语法，跟数据库无关，跟<code>NULL</code>或非<code>NULL</code>无关。</p>
<p><font color='sienna'>说明：</font><code>count(*)</code>会统计值为<code>NULL</code>的行，而<code>count(列名)</code>不会统计此列为NULL值的行。</p>
</li>
<li><p><font color='red'>【强制】</font><code>count(distinct col)</code>计算该列除<code>NULL</code>之外的不重复行数，注意<code>count(distinct col1,col2)</code>如果其中一列全为<code>NULL</code>，那么及时另一列有不同的值，也返回0</p>
</li>
<li><p><font color='red'>【强制】</font>当某一列的值全是<code>NULL</code>时，<code>count(col)</code>的返回结果为0，但是<code>sum(col)</code>的返回结果为<code>NULL</code>，因此使用<code>sum()</code>时需注意<code>NPE</code>问题</p>
<p><font color='green'>正例：</font>可以使用如下方式来避免sum的NPE问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(ISNULL(<span class="built_in">SUM</span>(g)),<span class="number">0</span>,<span class="built_in">SUM</span>(g))<span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><font color='red'>【强制】</font>使用<code>ISNULL()</code>来判断是否为<code>NULL</code>值。</p>
<p><font color='sienna'>说明：</font><code>NULL</code>与任何值的直接比较都为<code>NULL</code></p>
<ul>
<li><code>NULL&lt;&gt;NULL</code>的返回结果是<code>NULL</code>，而不是<code>false</code></li>
<li><code>NULL=NULL</code>的结果返回值是<code>NULL</code>，而不是<code>true</code></li>
<li><code>NULL&lt;&gt;1</code>的返回结果是<code>NULL</code>，而不是<code>true</code></li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句</p>
</li>
<li><p><font color='red'>【强制】</font>不得使用外检或级联，一切外键概念必须在应用层解决</p>
<p><font color='sienna'>说明：</font>以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p>
</li>
<li><p><font color='red'>【强制】</font>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</li>
<li><p><font color='red'>【强制】</font>数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误后才能执行更新语句</p>
</li>
<li><p><font color='green'>【推荐】</font><code>in</code>操作能避免则避免，是在避免不了，需要仔细评估<code>in</code>后边集合元素数量，控制在1000个内。</p>
</li>
<li><p><font color='green'>【参考】</font>注意字符串统计函数的区别</p>
<p><font color='sienna'>说明：</font></p>
<ul>
<li><font color='red'>SELECT LENGTH(“轻松工作”);返回12</font></li>
<li>SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4</li>
<li>如果需要存储表情，那么选择<code>utf8mb4</code>来进行存储，注意它与<code>utf-8</code>编码区别</li>
</ul>
</li>
<li><p><font color='green'>【参考】</font>TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE<br>无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句</p>
<p><font color='sienna'>说明：</font>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同</p>
</li>
</ol>
<h2 id="（四）ORM映射"><a href="#（四）ORM映射" class="headerlink" title="（四）ORM映射"></a>（四）ORM映射</h2><ol>
<li><p><font color='red'>【强制】</font>在表查询中，一律不要使用*作为查询的字段列表，需要哪些字段必须明确写明</p>
<p><font color='sienna'>说明：</font></p>
<ul>
<li>增加查询分析器解析成本</li>
<li>增减字段容易与<code>resultMap</code>配置不一致</li>
<li>无用字段增加网络小号，尤其是<code>text</code>类型字段</li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>不要用<code>resultClass</code>当返回参数，及时所有的类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必须有一个<code>POJO</code>类与之对应</p>
<p><font color='sienna'>说明：</font>配置映射关系，是字段与DO类解耦，方便维护</p>
</li>
<li><p><font color='red'>【强制】</font><code>sql.xml</code> 配置参数使用：<code>#&#123;&#125;，#param#</code> 不要使用${} 此种方式容易出现<code> SQL</code> 注入</p>
</li>
<li><p><font color='red'>【强制】</font>不允许直接拿<code>HashMap</code>与<code>Hashtable</code>作为查询结果集的输出。</p>
<p><font color='sienna'>说明：</font><code>resultClass=”Hashtable”</code>，会置入字段名和属性值，但是值的类型不可控</p>
</li>
<li><p><font color='red'>【强制】</font>不要写一个大而全的数据更新接口。传入为 <code>POJO</code> 类，不管是不是自己的目标更新字段，都进行 <code>update table set c1=value1,c2=value2,c3=value3;</code> 这是不对的。执行 <code>SQL</code>时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 <code>binlog</code> 存储</p>
</li>
<li><p><font color='green'>【参考】</font>@Transactional 事务不要滥用。事务会影响数据库的 <code>QPS</code>，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等</p>
</li>
</ol>
<h1 id="五、Oracle数据库"><a href="#五、Oracle数据库" class="headerlink" title="五、Oracle数据库"></a>五、Oracle数据库</h1><h2 id="（一）对象命名规范"><a href="#（一）对象命名规范" class="headerlink" title="（一）对象命名规范"></a>（一）对象命名规范</h2><ol>
<li><p><font color='red'>【强制】</font>数据库名称定义为系统名+模块名</p>
<p><font color='sienna'>说明：</font></p>
<ul>
<li>全局数据库名和SID名要求一致</li>
<li>因SID名只能包含字符和数字，所以全局数据库和SID名中不能含有“_”等字符</li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>表空间命名规范</p>
<ul>
<li>面向用户的专用数据表空间以<code>用户名+_+data</code>命名 ，如<code>Aud</code> 用户专用数据表空间可命名为<code>Aud_data</code></li>
<li>面向用户的专用索引表空间以<code>用户名+_+idx</code>命名</li>
<li>面向用户的专用临时表空间以<code>用户名+_+tmp</code>命名</li>
<li>面向用户的专用回滚段表空间以<code>用户名+_+rbs</code>命名</li>
<li>面向应用的表空间以<code>应用名+_data/应用名+_idx/应用名+_tmp/应用名+_rbs</code> 命名</li>
<li>LOB 段数据专用表空间以其<code>数据表空间+_+lobs</code> 命名，如上例中数据表空间为<code>Aud_data</code>，则LOB 段表空间可命名为<code>Aud_data_lobs</code></li>
<li>表空间文件命名以表空间名+两位数序号(序号从01开始)组成，如Aud_data01 等</li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>表名的命名规范</p>
<ul>
<li><p>一般表采用<code>系统名+t_+模块名+_+表义名</code> 格式构成</p>
</li>
<li><p>若数据库中只含有单个模块，命名可采用<code>系统名+t_+表义名</code>格式构成</p>
</li>
<li><p>模块名或表义名均以其汉语拼音的首字符命名，表义名中汉语拼音均采用小写，且字符间不加分割符</p>
</li>
<li><p>表别名命名规则：取表义名的前3 个字符加最后一个字符。如果存在冲突，适当增加字符（如取表义名的前4 个字符加最后一个字符等）</p>
</li>
<li><p>临时表采用<code>系统名+t_tmp_+表义名</code> 格式构成</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dft_gy_cbap：系统名（电费 df）<span class="operator">+</span>t_<span class="operator">+</span>模块名（高压 gy）<span class="operator">+</span>_<span class="operator">+</span>表义名（抄表安排 cbap）</span><br><span class="line">dft_cbbj: 系统名（电费 df）<span class="operator">+</span>t_<span class="operator">+</span>表义名（抄表标记 cbbj）</span><br><span class="line">dft_tmp_hj: 系统名（电费 df）<span class="operator">+</span>tmp<span class="operator">+</span>表义名（合计hj）(此处为临时表)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>属性（列或字段）命名规则</p>
<ul>
<li>采用有意义的列名，为实际含义的汉语拼音的首字符，且字符间不加任何分割符</li>
<li>属性名前不要加表名等作为前缀</li>
<li>属性后不加任何类型标识作为后缀</li>
<li>不要使用“ID”作为列名</li>
<li>关联字段命名以 <code>cd+_+关联表的表义名（或缩写）+_+字段名</code>进行</li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>主键命名规则</p>
<ul>
<li>任何表都必须定义主键</li>
<li>表主键命名为：<code>pk+_+表名(或缩写)+_+主键标识</code>如<code>pk_YHXX_IDKH</code>等</li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>外键命名规则</p>
<ul>
<li>表外键命名为： <code>fk+_+表名(或缩写)+_主表名(或缩写)+_+主键标识</code>如<code>fk_YHLX_YHXX_SFZH</code>等</li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>CHECK约束命名规则</p>
<ul>
<li>CHECK 约束命名为： <code>chk+_+CHECK约束的列名</code>（或缩写）</li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>UNIQUE约束命名规则</p>
<ul>
<li>UNIQUE 约束命名为： <code>unq+_+UNIQUE约束的列名（或缩写）</code></li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>索引命名规则</p>
<ul>
<li>索引的命名为：<code>表名（或缩写）+_+列名+_idx</code>，其中多单词组成的属性列列名取前几个单词首字符再加末单词首字符组成如<code>yd_kh</code> 表<code>khid</code>上的<code>index: yd_kh_khid_idx</code></li>
</ul>
</li>
<li><p><font color='red'>【强制】</font>视图命名规则</p>
<p>视图命名以<code>系统名v_+模块名</code>作为前缀，其他命名规则和表的命名类似</p>
</li>
</ol>
<h2 id="（二）SQL编写规范"><a href="#（二）SQL编写规范" class="headerlink" title="（二）SQL编写规范"></a>（二）SQL编写规范</h2><ol>
<li><p><font color='red'>【强制】</font>表面使用数据库类型的自动转换功能</p>
<p><font color='orange'>反例：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> category <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>; <span class="comment">-- id如果是数字类型的，在这就需要内置转换，所以尽量保持数据类型一致</span></span><br></pre></td></tr></table></figure></li>
<li><p><font color='green'>【参考】</font>SELECT语句编写规范</p>
<ul>
<li>关键字大写，列表名表名小写</li>
<li>由SELECT 开头，后跟一个显示查询结果的列表</li>
<li>由FROM 开头，后跟一个或多个获取数据所涉及的表</li>
<li>由WHERE 开头，后跟一个或多个确定所需值的条件</li>
<li>由GROUP BY开头，后跟一个或多个表列名，通过这些列以对查询结果进行汇总</li>
<li>由ORDER BY开头，后跟一个或多个表列名，通过这些列以对查询结果进行排序</li>
</ul>
</li>
<li><p><font color='green'>【参考】</font>尽量避免在循环中使用<code>SQL</code>语句</p>
</li>
<li><p><font color='green'>【参考】</font>避免在<code>WHERE</code>子句中对列施以函数；</p>
<p><font color='green'>正例：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> service_promotion</span><br><span class="line"><span class="keyword">WHERE</span> gmt_modified</span><br><span class="line"><span class="operator">&gt;=</span> TO_DATE(<span class="string">&#x27;2001-9-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> gmt_modified</span><br><span class="line"><span class="operator">&lt;</span> TO_DATE(<span class="string">&#x27;2001-9-02&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><font color='orange'>反例：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>　service_promotion</span><br><span class="line"><span class="keyword">WHERE</span> TO_CHAR(gmt_modified,’yyyy<span class="operator">-</span>mm<span class="operator">-</span>dd’)</span><br><span class="line"><span class="operator">=</span> <span class="string">&#x27;20001-09-01&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="（三）类型选择"><a href="#（三）类型选择" class="headerlink" title="（三）类型选择"></a>（三）类型选择</h2><ol>
<li><font color='red'>【强制】</font>不同的数据类型选择不同的数据存储类型，不要什么都用<code>varchar2</code><ul>
<li>用<code>char(1)</code>代表布尔值</li>
<li>应尽量使用<code>varchar2</code>代替<code>char</code>类型</li>
<li><code>varchar2</code>最多4000字符</li>
<li><code>date</code>精确到微秒，而非天</li>
<li>使用<code>clob</code>代替<code>long</code>,<code>blob</code>代替<code>long</code> <code>raw</code></li>
<li>oracle只有number一种数据类型，使用时请给定长度</li>
</ul>
</li>
</ol>
<h1 id="附件：专有名词解释"><a href="#附件：专有名词解释" class="headerlink" title="附件：专有名词解释"></a>附件：专有名词解释</h1><ol>
<li><strong>POJO</strong>（<code>Plain Ordinary Java Object</code>）：在本手册中，<code>POJO</code>专指只有<code>setter/getter/toString</code>的简单类，包括<code>DO/DTO/BO/VO</code>等</li>
<li><strong>OOP</strong>（<code>Object Oriented Programming</code>）：本手册泛指类、对象的变成处理方式</li>
<li><strong>ORM</strong>（<code>Object Relation Mapping</code>）：对象关系映射，对象领域模型与底层数据之间的转换，本文繁殖<code>iBATIS</code>，<code>mybatis</code>等框架</li>
<li><strong>NPE</strong>（<code>java.lang.NullPointterException</code>）：空指针异常</li>
<li><strong>IDE</strong>（<code>Integrated Development Environment</code>）：用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具，本手册泛指<code>IDEA</code>和<code>Eclipse</code></li>
<li><strong>OOM</strong>（<code>Out of Memory</code>）：源于<code>java.lang.OutOfMemoryError</code>，当<code>JVM</code>没有足够的内存来为对象分配空间并且垃圾回收无法回收空间时，系统出现的严重状况</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" rel="tag"># 编码规范</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/01/23/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%AF%B9%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81%E5%8A%A0%E8%A7%A3%E5%AF%86/" rel="prev" title="用户登录对账号和密码加解密">
                  <i class="fa fa-chevron-left"></i> 用户登录对账号和密码加解密
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/01/24/Java%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/" rel="next" title="Java子线程执行完毕之后，主线程继续执行">
                  Java子线程执行完毕之后，主线程继续执行 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鲁ICP备19005853号-1 </a>
  </div>

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Daniel</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
